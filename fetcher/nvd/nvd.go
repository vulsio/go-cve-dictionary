package nvd

import (
	"archive/tar"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/fs"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"slices"
	"strings"
	"time"

	"github.com/hashicorp/go-version"
	"github.com/klauspost/compress/zstd"
	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
	"github.com/spf13/viper"
	"golang.org/x/xerrors"
	"oras.land/oras-go/v2"
	"oras.land/oras-go/v2/registry/remote"

	"github.com/vulsio/go-cve-dictionary/fetcher"
	"github.com/vulsio/go-cve-dictionary/log"
	"github.com/vulsio/go-cve-dictionary/models"
	"github.com/vulsio/go-cve-dictionary/util"
)

// Fetch Fetch CVE vulnerability information from NVD
func Fetch() (string, error) {
	dir, err := os.MkdirTemp("", "go-cve-dictionary")
	if err != nil {
		return "", xerrors.Errorf("Failed to create temp directory. err: %w", err)
	}

	if err := fetch(dir); err != nil {
		return "", xerrors.Errorf("Failed to fetch vuls-data-raw-nvd-api-cve. err: %w", err)
	}

	return dir, nil
}

func fetch(dir string) error {
	ctx := context.TODO()
	repo, err := remote.NewRepository("ghcr.io/vulsio/vuls-data-db:vuls-data-raw-nvd-api-cve")
	if err != nil {
		return xerrors.Errorf("Failed to create client for ghcr.io/vulsio/vuls-data-db:vuls-data-raw-nvd-api-cve. err: %w", err)
	}

	_, r, err := oras.Fetch(ctx, repo, repo.Reference.Reference, oras.DefaultFetchOptions)
	if err != nil {
		return xerrors.Errorf("Failed to fetch manifest. err: %w", err)
	}
	defer r.Close()

	var manifest ocispec.Manifest
	if err := json.NewDecoder(r).Decode(&manifest); err != nil {
		return xerrors.Errorf("Failed to decode manifest. err: %w", err)
	}

	l := func() *ocispec.Descriptor {
		for _, l := range manifest.Layers {
			if l.MediaType == "application/vnd.vulsio.vuls-data-db.dotgit.layer.v1.tar+zstd" {
				return &l
			}
		}
		return nil
	}()
	if l == nil {
		return xerrors.Errorf("Failed to find digest and filename from layers, actual layers: %#v", manifest.Layers)
	}

	r, err = repo.Fetch(ctx, *l)
	if err != nil {
		return xerrors.Errorf("Failed to fetch content. err: %w", err)
	}
	defer r.Close()

	zr, err := zstd.NewReader(r)
	if err != nil {
		return xerrors.Errorf("Failed to new zstd reader. err: %w", err)
	}
	defer zr.Close()

	tr := tar.NewReader(zr)
	for {
		hdr, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return xerrors.Errorf("Failed to next tar reader. err: %w", err)
		}

		p := filepath.Join(dir, hdr.Name)

		switch hdr.Typeflag {
		case tar.TypeDir:
			if err := os.MkdirAll(p, 0755); err != nil {
				return xerrors.Errorf("Failed to mkdir %s. err: %w", p, err)
			}
		case tar.TypeReg:
			if err := os.MkdirAll(filepath.Dir(p), 0755); err != nil {
				return xerrors.Errorf("Failed to mkdir %s. err: %w", p, err)
			}

			if err := func() error {
				f, err := os.Create(p)
				if err != nil {
					return xerrors.Errorf("Failed to create %s. err: %w", p, err)
				}
				defer f.Close()

				if _, err := io.Copy(f, tr); err != nil {
					return xerrors.Errorf("Failed to copy to %s. err: %w", p, err)
				}

				return nil
			}(); err != nil {
				return xerrors.Errorf("Failed to create %s. err: %w", p, err)
			}
		}
	}

	cmd := exec.Command("git", "-C", filepath.Join(dir, "vuls-data-raw-nvd-api-cve"), "restore", ".")
	if err := cmd.Run(); err != nil {
		return xerrors.Errorf("Failed to exec %q. err: %w", cmd.String(), err)
	}

	return nil
}

// Convert convert <tempDir>/vuls-data-raw-nvd-api-cve/<year>/CVE-<year>-\d{4,}.json to []models.Nvd
func Convert(tempDir, year string) ([]models.Nvd, error) {
	var ps []string
	if err := filepath.WalkDir(filepath.Join(tempDir, "vuls-data-raw-nvd-api-cve", year), func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		ps = append(ps, path)
		return nil
	}); err != nil {
		return nil, xerrors.Errorf("Failed to walk %s. err: %w", filepath.Join(tempDir, year), err)
	}

	reqChan := make(chan string, len(ps))
	resChan := make(chan *models.Nvd, len(ps))
	errChan := make(chan error, len(ps))
	defer close(reqChan)
	defer close(resChan)
	defer close(errChan)

	go func() {
		for _, p := range ps {
			reqChan <- p
		}
	}()

	concurrency := runtime.NumCPU() + 2
	tasks := util.GenWorkers(concurrency)
	for range ps {
		tasks <- func() {
			req := <-reqChan
			cve, err := convertToModel(req)
			if err != nil {
				errChan <- err
				return
			}
			resChan <- cve
		}
	}

	cves := []models.Nvd{}
	errs := []error{}
	timeout := time.After(10 * 60 * time.Second)
	for range ps {
		select {
		case res := <-resChan:
			if res != nil {
				cves = append(cves, *res)
			}
		case err := <-errChan:
			errs = append(errs, err)
		case <-timeout:
			return nil, fmt.Errorf("Timeout Fetching")
		}
	}
	if 0 < len(errs) {
		return nil, xerrors.Errorf("%w", errs)
	}
	return cves, nil
}

// convertToModel converts Nvd JSON to model structure.
func convertToModel(cvePath string) (*models.Nvd, error) {
	f, err := os.Open(cvePath)
	if err != nil {
		return nil, xerrors.Errorf("Failed to open %s. err: %w", cvePath, err)
	}
	defer f.Close()

	var item cve
	if err := json.NewDecoder(f).Decode(&item); err != nil {
		return nil, xerrors.Errorf("Failed to decode %s. err: %w", cvePath, err)
	}

	if item.VulnStatus == "Rejected" {
		return nil, nil
	}

	// Description
	descs := []models.NvdDescription{}
	for _, desc := range item.Descriptions {
		descs = append(descs, models.NvdDescription{
			Lang:  desc.Lang,
			Value: desc.Value,
		})
	}

	//References
	refs := []models.NvdReference{}
	for _, r := range item.References {
		refs = append(refs, models.NvdReference{
			Reference: models.Reference{
				Link:   r.URL,
				Name:   r.URL,
				Source: r.Source,
				Tags:   strings.Join(r.Tags, ","),
			},
		})
	}

	// Certs
	certs := []models.NvdCert{}
	for _, ref := range item.References {
		if !strings.HasPrefix(ref.URL, "http") {
			continue
		}
		if strings.Contains(ref.URL, "us-cert") {
			ss := strings.Split(ref.URL, "/")
			title := fmt.Sprintf("US-CERT-%s", ss[len(ss)-1])
			certs = append(certs, models.NvdCert{
				Cert: models.Cert{
					Link:  ref.URL,
					Title: title,
				},
			})
		}
	}

	// Cwes
	cwes := []models.NvdCwe{}
	for _, weak := range item.Weaknesses {
		for _, desc := range weak.Description {
			if !slices.ContainsFunc(cwes, func(e models.NvdCwe) bool {
				return e.Source == weak.Source && e.Type == weak.Type && e.CweID == desc.Value
			}) {
				cwes = append(cwes, models.NvdCwe{
					Source: weak.Source,
					Type:   weak.Type,
					CweID:  desc.Value,
				})
			}
		}
	}

	full := viper.GetBool("full")
	cpes := []models.NvdCpe{}
	for _, conf := range item.Configurations {
		if conf.Negate {
			continue
		}

		var (
			nodeCpes    []models.NvdCpe
			nodeEnvCpes []models.NvdEnvCpe
		)
		for _, node := range conf.Nodes {
			if node.Negate {
				continue
			}

			for _, cpe := range node.CPEMatch {
				if cpe.Vulnerable {
					cpeBase, err := fetcher.ParseCpeURI(cpe.Criteria)
					if err != nil {
						log.Infof("Failed to parse CpeURI %s: %s", cpe.Criteria, err)
						continue
					}
					cpeBase.VersionStartExcluding = cpe.VersionStartExcluding
					cpeBase.VersionStartIncluding = cpe.VersionStartIncluding
					cpeBase.VersionEndExcluding = cpe.VersionEndExcluding
					cpeBase.VersionEndIncluding = cpe.VersionEndIncluding
					nodeCpes = append(nodeCpes, models.NvdCpe{
						CpeBase: *cpeBase,
						EnvCpes: []models.NvdEnvCpe{},
					})
					if !checkIfVersionParsable(cpeBase) {
						return nil, fmt.Errorf("Version parse err. Please add a issue on [GitHub](https://github.com/vulsio/go-cve-dictionary/issues/new). Title: %s, Content: %v", item.ID, item)
					}
				} else {
					if !full || conf.Operator != "AND" {
						continue
					}
					cpeBase, err := fetcher.ParseCpeURI(cpe.Criteria)
					if err != nil {
						log.Infof("Failed to parse CpeURI %s: %s", cpe.Criteria, err)
						continue
					}
					cpeBase.VersionStartExcluding = cpe.VersionStartExcluding
					cpeBase.VersionStartIncluding = cpe.VersionStartIncluding
					cpeBase.VersionEndExcluding = cpe.VersionEndExcluding
					cpeBase.VersionEndIncluding = cpe.VersionEndIncluding
					nodeEnvCpes = append(nodeEnvCpes, models.NvdEnvCpe{
						CpeBase: *cpeBase,
					})
					if !checkIfVersionParsable(cpeBase) {
						return nil, fmt.Errorf("Version parse err. Please add a issue on [GitHub](https://github.com/vulsio/go-cve-dictionary/issues/new). Title: %s, Content: %v", item.ID, item)
					}
				}
			}
		}
		for _, nodeCpe := range nodeCpes {
			nodeCpe.EnvCpes = append(nodeCpe.EnvCpes, nodeEnvCpes...)
			cpes = append(cpes, nodeCpe)
		}
	}

	c2 := make([]models.NvdCvss2Extra, 0, len(item.Metrics.CVSSMetricV2))
	for _, v2 := range item.Metrics.CVSSMetricV2 {
		c2 = append(c2, models.NvdCvss2Extra{
			Source: v2.Source,
			Type:   v2.Type,
			Cvss2: models.Cvss2{
				VectorString:          v2.CvssData.VectorString,
				AccessVector:          v2.CvssData.AccessVector,
				AccessComplexity:      v2.CvssData.AccessComplexity,
				Authentication:        v2.CvssData.Authentication,
				ConfidentialityImpact: v2.CvssData.ConfidentialityImpact,
				IntegrityImpact:       v2.CvssData.IntegrityImpact,
				AvailabilityImpact:    v2.CvssData.AvailabilityImpact,
				BaseScore:             v2.CvssData.BaseScore,
				Severity:              v2.BaseSeverity,
			},
			ExploitabilityScore:     v2.ExploitabilityScore,
			ImpactScore:             v2.ImpactScore,
			ObtainAllPrivilege:      v2.ObtainAllPrivilege,
			ObtainUserPrivilege:     v2.ObtainUserPrivilege,
			ObtainOtherPrivilege:    v2.ObtainOtherPrivilege,
			UserInteractionRequired: v2.UserInteractionRequired,
		})
	}

	c3 := make([]models.NvdCvss3, 0, len(item.Metrics.CVSSMetricV30)+len(item.Metrics.CVSSMetricV31))
	for _, v30 := range item.Metrics.CVSSMetricV30 {
		c3 = append(c3, models.NvdCvss3{
			Source: v30.Source,
			Type:   v30.Type,
			Cvss3: models.Cvss3{
				VectorString:          v30.CVSSData.VectorString,
				AttackVector:          v30.CVSSData.AttackVector,
				AttackComplexity:      v30.CVSSData.AttackComplexity,
				PrivilegesRequired:    v30.CVSSData.PrivilegesRequired,
				UserInteraction:       v30.CVSSData.UserInteraction,
				Scope:                 v30.CVSSData.Scope,
				ConfidentialityImpact: v30.CVSSData.ConfidentialityImpact,
				IntegrityImpact:       v30.CVSSData.IntegrityImpact,
				AvailabilityImpact:    v30.CVSSData.AvailabilityImpact,
				BaseScore:             v30.CVSSData.BaseScore,
				BaseSeverity:          v30.CVSSData.BaseSeverity,
				ExploitabilityScore:   v30.ExploitabilityScore,
				ImpactScore:           v30.ImpactScore,
			},
		})
	}
	for _, v31 := range item.Metrics.CVSSMetricV31 {
		c3 = append(c3, models.NvdCvss3{
			Source: v31.Source,
			Type:   v31.Type,
			Cvss3: models.Cvss3{
				VectorString:          v31.CVSSData.VectorString,
				AttackVector:          v31.CVSSData.AttackVector,
				AttackComplexity:      v31.CVSSData.AttackComplexity,
				PrivilegesRequired:    v31.CVSSData.PrivilegesRequired,
				UserInteraction:       v31.CVSSData.UserInteraction,
				Scope:                 v31.CVSSData.Scope,
				ConfidentialityImpact: v31.CVSSData.ConfidentialityImpact,
				IntegrityImpact:       v31.CVSSData.IntegrityImpact,
				AvailabilityImpact:    v31.CVSSData.AvailabilityImpact,
				BaseScore:             v31.CVSSData.BaseScore,
				BaseSeverity:          v31.CVSSData.BaseSeverity,
				ExploitabilityScore: func() float64 {
					if v31.ExploitabilityScore != nil {
						return *v31.ExploitabilityScore
					}
					return 0
				}(),
				ImpactScore: func() float64 {
					if v31.ImpactScore != nil {
						return *v31.ImpactScore
					}
					return 0
				}(),
			},
		})
	}
	c40 := make([]models.NvdCvss40, 0, len(item.Metrics.CVSSMetricV40))
	for _, v40 := range item.Metrics.CVSSMetricV40 {
		c40 = append(c40, models.NvdCvss40{
			Source: v40.Source,
			Type:   v40.Type,
			Cvss40: models.Cvss40{
				VectorString:          v40.CVSSData.VectorString,
				BaseScore:             v40.CVSSData.BaseScore,
				BaseSeverity:          v40.CVSSData.BaseSeverity,
				ThreatScore:           v40.CVSSData.ThreatScore,
				ThreatSeverity:        v40.CVSSData.ThreatSeverity,
				EnvironmentalScore:    v40.CVSSData.EnvironmentalScore,
				EnvironmentalSeverity: v40.CVSSData.EnvironmentalSeverity,
			},
		})
	}

	publish, err := parseNvdTime(item.Published)
	if err != nil {
		return nil, xerrors.Errorf("Failed to parse NVD Time. err: %w", err)
	}
	modified, err := parseNvdTime(item.LastModified)
	if err != nil {
		return nil, xerrors.Errorf("Failed to parse NVD Time. err: %w", err)
	}

	return &models.Nvd{
		CveID:            item.ID,
		Descriptions:     descs,
		Cvss2:            c2,
		Cvss3:            c3,
		Cvss40:           c40,
		Cwes:             cwes,
		Cpes:             cpes,
		References:       refs,
		Certs:            certs,
		PublishedDate:    publish,
		LastModifiedDate: modified,
	}, nil
}

func checkIfVersionParsable(cpeBase *models.CpeBase) bool {
	if cpeBase.Version != "ANY" && cpeBase.Version != "NA" {
		vers := []string{cpeBase.VersionStartExcluding,
			cpeBase.VersionStartIncluding,
			cpeBase.VersionEndIncluding,
			cpeBase.VersionEndExcluding}
		for _, v := range vers {
			if v == "" {
				continue
			}
			v := strings.Replace(v, `\`, "", -1)
			if _, err := version.NewVersion(v); err != nil {
				return false
			}
		}
	}
	return true
}

func parseNvdTime(strtime string) (t time.Time, err error) {
	layout := "2006-01-02T15:04:05.000"
	t, err = time.Parse(layout, strtime)
	if err != nil {
		return t, xerrors.Errorf("Failed to parse time, time: %s, err: %w", strtime, err)
	}
	return
}
